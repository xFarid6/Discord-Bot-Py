class Slapper(commands.Converter):
    async def convert(self, ctx, argument):
        to_slap = random.choice(ctx.guild.members)
        return f'{ctx.author} slapped {to_slap} because *{argument}*'


@bot.command()
async def slap(ctx, *, reason: Slapper):
    await ctx.send(reason)


@bot.command()
async def clean(ctx, *, content: commands.clean_content):
    await ctx.send(content)

# or for fine-tuning

@bot.command()
async def clean(ctx, *, content: commands.clean_content(use_nicknames=False)):
    await ctx.send(content)


class JoinDistance:
    def __init__(self, joined, created):
        self.joined = joined
        self.created = created

    @classmethod
    async def convert(cls, ctx, argument):
        member = await commands.MemberConverter().convert(ctx, argument)
        return cls(member.joined_at, member.created_at)

    @property
    def delta(self):
        return self.joined - self.created

@bot.command()
async def delta(ctx, *, member: JoinDistance):
    is_new = member.delta.days < 100
    if is_new:
        await ctx.send("Hey you're pretty new!")
    else:
        await ctx.send("Hm you're not so new.")


@bot.command()
async def joined(ctx, *, member: discord.Member):
    await ctx.send(f'{member} joined on {member.joined_at}')


@cool.command(name='bot')
async def _bot(ctx):
    """Is the bot cool?"""
    await ctx.send('Yes, the bot is cool.')


@bot.command()
async def ping(ctx):
    await ctx.send('Pong!')


@bot.command()
async def echo(ctx, *, message: str):
    await ctx.send(message)


@bot.command()
async def purge(ctx, amount: int):
    await ctx.channel.purge(limit=amount)


@bot.command()
@bot.command(aliases=['8ball'])
async def _8ball(ctx, *, question):
    responses = [
        'That is a response to a question.',
        'It is certain.',
        'It is decidedly so.',
        'Without a doubt.',
        'Yes - definitely.',
        'You may rely on it.',
        'As I see it, yes.',
        'Most likely.',
        'Outlook good.',
        'Yes.',
        'Signs point to yes.',

        'Reply has not been heard yet.',
        'My sources say no.',
        'Outlook not so good.',
        'Very doubtful.',
        'My reply is no.',
        'My sources say no.',
        'My reply is no.',
        'My sources say no.',
        'My sources say no.',
    ]
    await ctx.send(f'Question: {question}\nAnswer: {random.choice(responses)}')


@bot.command()
async def kick(ctx, member: discord.Member, *, reason: str):
    await member.kick(reason=reason)


@bot.command()
@bot.has_permissions(administrator=True)
async def ban(ctx, member: discord.Member, *, reason: str):
    await member.ban(reason=reason)


"""async def on_message(self, message):
        if message.content.startswith('!deleteme'):
            msg = await message.channel.send('I will delete myself now...')
            await msg.delete()

            # this also works
            await message.channel.send('Goodbye in 3 seconds...', delete_after=3.0)

async def on_message_delete(self, message):
    fmt = '{0.author} has deleted the message: {0.content}'
    await message.channel.send(fmt.format(message))
    
    
 async def on_message(self, message):
        if message.content.startswith('!editme'):
            msg = await message.channel.send('10')
            await asyncio.sleep(3.0)
            await msg.edit(content='40')

async def on_message_edit(self, before, after):
    fmt = '**{0.author}** edited their message:\n{0.content} -> {1.content}'
    await before.channel.send(fmt.format(before, after))


 async def on_member_join(self, member):
        guild = member.guild
        if guild.system_channel is not None:
            to_send = 'Welcome {0.mention} to {1.name}!'.format(member, guild)
            await guild.system_channel.send(to_send)


    self.emoji_to_role = {
                discord.PartialEmoji(name='ðŸ”´'): 0, # ID of the role associated with unicode emoji 'ðŸ”´'.
                discord.PartialEmoji(name='ðŸŸ¡'): 0, # ID of the role associated with unicode emoji 'ðŸŸ¡'.
                discord.PartialEmoji(name='green', id=0): 0, # ID of the role associated with a partial emoji's ID.
            }

    async def on_raw_reaction_add(self, payload: discord.RawReactionActionEvent):
        ""Gives a role based on a reaction emoji.""
        # Make sure that the message the user is reacting to is the one we care about.
        if payload.message_id != self.role_message_id:
            return

        guild = self.get_guild(payload.guild_id)
        if guild is None:
            # Check if we're still in the guild and it's cached.
            return

        try:
            role_id = self.emoji_to_role[payload.emoji]
        except KeyError:
            # If the emoji isn't the one we care about then exit as well.
            return

        role = guild.get_role(role_id)
        if role is None:
            # Make sure the role still exists and is valid.
            return

        try:
            # Finally, add the role.
            await payload.member.add_roles(role)
        except discord.HTTPException:
            # If we want to do something in case of errors we'd do it here.
            pass

    async def on_raw_reaction_remove(self, payload: discord.RawReactionActionEvent):
        ""Removes a role based on a reaction emoji.""
        # Make sure that the message the user is reacting to is the one we care about.
        if payload.message_id != self.role_message_id:
            return

        guild = self.get_guild(payload.guild_id)
        if guild is None:
            # Check if we're still in the guild and it's cached.
            return

        try:
            role_id = self.emoji_to_role[payload.emoji]
        except KeyError:
            # If the emoji isn't the one we care about then exit as well.
            return

        role = guild.get_role(role_id)
        if role is None:
            # Make sure the role still exists and is valid.
            return

        # The payload for `on_raw_reaction_remove` does not provide `.member`
        # so we must get the member ourselves from the payload's `.user_id`.
        member = guild.get_member(payload.user_id)
        if member is None:
            # Make sure the member still exists and is valid.
            return

        try:
            # Finally, remove the role.
            await member.remove_roles(role)
        except discord.HTTPException:
            # If we want to do something in case of errors we'd do it here.
            pass
"""

